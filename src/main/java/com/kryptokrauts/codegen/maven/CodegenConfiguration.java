package com.kryptokrauts.codegen.maven;

import com.kryptokrauts.aeternity.sdk.service.aeternity.AeternityServiceConfiguration;
import com.kryptokrauts.aeternity.sdk.service.aeternity.AeternityServiceFactory;
import com.kryptokrauts.aeternity.sdk.service.aeternity.impl.AeternityService;
import io.vertx.core.Vertx;
import io.vertx.core.VertxOptions;
import java.lang.reflect.Modifier;
import java.util.Arrays;
import lombok.Getter;
import lombok.Setter;
import org.apache.maven.plugin.MojoExecutionException;

@Getter
@Setter
public class CodegenConfiguration {

  private static AeternityService aeternityService;

  /** The package for generated contracts */
  private String targetPackage = "com.kryptokrauts.contraect.generated";

  /** The package for autogenerated sophia datatypes */
  private String datatypePackage = "com.kryptokrauts.contraect.generated.datatypes";

  /** The path where generated contracts are created */
  private String targetPath = "target/generated-sources/contraect";

  /** url to sophia compiler, necessary to get abi from source file */
  private String compilerBaseUrl;

  /** number of trials to wait for a transaction to be mined (stateful calls, deploy) */
  private int numTrials = 60;

  /** the directories to be scanned for contracts */
  private String[] directories;

  /** file suffix identifying contract code files */
  private String contractSuffix = "aes";

  public AeternityService getAeternityService() {
    if (aeternityService == null) {
      VertxOptions options = new VertxOptions();
      options
          .getFileSystemOptions()
          .setFileCachingEnabled(false)
          .setClassPathResolvingEnabled(false);
      options.getMetricsOptions().setEnabled(false);
      Vertx vertxInstance = Vertx.vertx(options);
      aeternityService =
          new AeternityServiceFactory()
              .getService(
                  AeternityServiceConfiguration.configure()
                      .vertx(vertxInstance)
                      .compilerBaseUrl(this.compilerBaseUrl)
                      .compile());
    }
    return aeternityService;
  }

  public void validate() {
    Arrays.asList(this.getClass().getDeclaredFields()).stream()
        .forEach(
            field -> {
              if (!Modifier.isStatic(field.getModifiers())) {
                try {
                  if (field.get(this) == null) {
                    throwMojoExecutionException(field.getName());
                  }
                } catch (Exception e) {
                  throw new RuntimeException(e);
                }
              }
            });
  }

  private void throwMojoExecutionException(String attribute) throws MojoExecutionException {
    throw new MojoExecutionException(
        String.format("Required attribute codegen.%s not set", attribute));
  }
}
